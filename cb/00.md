
![反思总结](cb1.md#反思与总结)


## *11*

```dataviewjs
//输入目标小标题（含#），例如：#### 项目进度条 
const header = '### 反思与总结'
// 按【路径或文件夹、文件名、标签】筛选并按修改时间降序排列 
const pages = dv.pages('"cb"').filter(p => p.file.name.includes("") && !p.file.path.includes("template")).filter(p => p.file.name.includes("") || p.file.name.includes("")).sort(p => p.file.mtime, "desc");

const regex = new RegExp(`\n${header}\r?\n(.*?)(\n#+ |\n---|$)`, 'gm')
for (const page of pages) {
    const file = app.vault.getAbstractFileByPath(page.file.path)
    let fc = app.metadataCache.getFileCache(file)
    // console.error("sections",fc)
    // Read the file contents 
    const contents = await app.vault.read(file)
    // console.error("page",page)
    // Extract the summary via regex 
    const summary = contents.match(regex)
    // const summary = regex.exec(contents)
    // console.error("summary",summary)
    //显示全部包括空结果
    // if (summary) { 
    //不显示空结果
    if (summary && summary[1].trim()) {
        // Output the header and summary 
        dv.header(2, page.file.link)
        // dv.header(2, '[[' + file.basename + ']]') 
        dv.paragraph(summary[1].trim())
    }
}
```



```dataviewjs 

const headers = ["cb", "内容"];
// 目标小标题，支持正则匹配
const targetHeading = /^.{0,9}反思与总结{0,4}$/i;
// 按【路径或文件夹、文件名、标签】筛选并按修改时间降序排列
const pages = dv.pages('"cb"').sort(p=>p.file.mtime,"desc");
const pagesArray = pages.array();
const targetPagesArray = [];
const contentArray = [];

for(let i = 0; i < pagesArray.length;i++) {
    const currentFile = pagesArray[i].file;
    const sectionCache = app.metadataCache.getFileCache(currentFile);

    const headingCache = sectionCache.headings?.filter(h => {
        return targetHeading.test(h.heading)
    })

    if(headingCache?.length > 0) {
        const headingRange = {
            start: headingCache[0].position.start.offset,
            end: headingCache[0].position.end.offset,
        };
        const heading = headingCache[0].heading;
        const content = await dv.io.load(currentFile.path);

        if(!content) continue;
        const headingInRange = content.slice(headingRange.start, headingRange.end);
        const contentInNextRange = content.slice(headingRange.end);

        const level = headingInRange.match(/#{1,6}/)[0].length;
        const nextHeadingRegex = new RegExp(`(^|\\n)#{1,${level}}\\s`);

        const position = contentInNextRange.match(nextHeadingRegex);

        let contentRange;
        let positionEnd;

        if(position) {
            positionEnd = headingRange.end + position?.index;
            contentRange = content.slice(headingRange.end, positionEnd);
        }else {
            contentRange = content.slice(headingRange.end);
        }
        const link = dv.sectionLink(currentFile.name, heading)
        contentArray.push({
            file: link,
            content: contentRange,
        })
    }
    //将结果限制在50条以内
    if (contentArray.length >= 50) {
        break;
    }
}
dv.table(headers, contentArray.map(
    p =>
        [
            p.file,
            p.content,
        ]
))


```



```query

反思与总结 from "cb"
```



```dataviewjs

```

```dataviewjs
let term = '反思与总结'; 
dv.paragraph(`###  ${term}`)
let files = dv.pages(`"cb"`).sort(p => p.file.name, "desc");
let rgx = /\[.*?\]\((?!http)(.+)|\[\[(.+?)\|(.*?\d+)?/

function extract(str) { let r = []; str.replace(rgx, (m, p1, p2) => { r.push(p1 || p2) }); return r[0] } files.map(async p => {
    // let fc = app.metadataCache.getFileCache(app.vault.getAbstractFileByPath(p.file.path)).headings.filter(p => p.level == 2) // 二级标题数组 
    let fc = app.metadataCache.getFileCache(app.vault.getAbstractFileByPath(p.file.path)).headings
    let A = (await app.vault.readRaw(p.file.path)).split('\n') // 分块 
    // console.error("A0",A)
    let B = ""
    let C = []
    for (let hi = 0; hi < fc.length; hi++) {
        if (fc[hi].heading == term) {
            B = fc[hi+1] ? A.slice(fc[hi].position.end.line + 1, fc[hi + 1].position.end.line) : A.slice(fc[hi].position.end.line + 1) // 截取 
            // console.error("a1",B)
            B = B.map(p => p.split(/!|\)|\]\]/).map(p => rgx.test(p) ? extract(p) : p)) // 再分块 
            console.error("a2",B)
            C.push(...B)
        }
    } 

    dv.paragraph(`##### ${p.file.link}\n${C.join('\n\n')}`) // 再合块、输出

    return

    // let B = p.file.outlinks.filter(p => p.embed && !/\.md$/.test(p.path))
    // for (let i = 0; i < A.length; i++) { 
    //     for (let j = 0; j < B.length; j++) {
    //         let b = B[j].path.split('/'); let dp = /.*?(?:\|)?(.*?)(?:\|)?(\d+)/.exec(B[j].display)
    //         let src = encodeURI(`${app.vault.adapter.basePath}/${B[j].path}`)
    //         A[i] = A[i].map(p=> { 
    //             let boo = p.replace( /\.\// ).includes('/') ?p.endsWith(b.slice(-2).join('/')) : p.endsWith(b.slice(-1))
    //             if (boo) { 
    //                 return dp ? `<img width='${dp[2]}' src='${src}'>` : `<img src='${src}'>` 
    //             }
    //             else { 
    //                 return p 
    //             } 
    //         })
    //     }
    //     A[i] = A[i].join('') // 合块 
    // };
    
})
```